{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "falling-symbols-background",
  "type": "registry:ui",
  "title": "Falling Symbols Background",
  "description": "A Matrix-style falling symbols background with customizable characters and effects.",
  "files": [
    {
      "path": "registry/ruixenui/falling-symbols-background.tsx",
      "content": "\"use client\";\nimport React, { useRef, useEffect, useCallback } from \"react\";\n\ninterface FallingSymbolsProps {\n  symbols?: string; // characters to display\n  symbolColors?: string[];\n  fontSize?: number;\n  backgroundColor?: string;\n  glitchSpeed?: number;\n  glitchIntensity?: number;\n  fallSpeed?: number;\n  outerVignette?: boolean;\n  className?: string;\n}\n\nconst FallingSymbolsBackground: React.FC<FallingSymbolsProps> = ({\n  symbols = \"░▒▓█▌▐\",\n  symbolColors = [\n    \"rgba(255,255,255,0.6)\",\n    \"rgba(255,255,255,0.4)\",\n    \"rgba(200,200,200,0.3)\",\n  ],\n  fontSize = 16,\n  backgroundColor = \"#080A12\",\n  glitchSpeed = 80,\n  glitchIntensity = 0.03,\n  fallSpeed = 0.7,\n  outerVignette = true,\n  className = \"w-full h-full\",\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const animationFrameId = useRef<number | null>(null);\n\n  const grid = useRef({ columns: 0, rows: 0, charWidth: 0, charHeight: 0 });\n  const letters = useRef<\n    Array<{ char: string; x: number; y: number; color: string }>\n  >([]);\n  const lastGlitchTime = useRef(0);\n\n  const getRandomChar = useCallback(\n    () => symbols[Math.floor(Math.random() * symbols.length)],\n    [symbols],\n  );\n\n  const getRandomColor = useCallback(\n    () => symbolColors[Math.floor(Math.random() * symbolColors.length)],\n    [symbolColors],\n  );\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    if (!canvas || !container) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    let canvasWidth = 0;\n    let canvasHeight = 0;\n\n    const setup = () => {\n      if (animationFrameId.current)\n        cancelAnimationFrame(animationFrameId.current);\n\n      const dpr = window.devicePixelRatio || 1;\n      const rect = container.getBoundingClientRect();\n      canvasWidth = rect.width;\n      canvasHeight = rect.height;\n      canvas.width = canvasWidth * dpr;\n      canvas.height = canvasHeight * dpr;\n      canvas.style.width = `${canvasWidth}px`;\n      canvas.style.height = `${canvasHeight}px`;\n\n      // reset transform and rescale\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.scale(dpr, dpr);\n\n      ctx.font = `${fontSize}px monospace`;\n      ctx.textBaseline = \"top\";\n\n      const charMetrics = ctx.measureText(\"M\");\n      grid.current = {\n        columns: Math.floor(canvasWidth / charMetrics.width),\n        rows: Math.floor(canvasHeight / (fontSize * 1.2)),\n        charWidth: charMetrics.width,\n        charHeight: fontSize * 1.2,\n      };\n\n      const extendedRows = grid.current.rows * 2;\n      const totalLetters = grid.current.columns * extendedRows;\n      letters.current = Array.from({ length: totalLetters }, (_, i) => {\n        const col = i % grid.current.columns;\n        const row = Math.floor(i / grid.current.columns);\n        return {\n          char: getRandomChar(),\n          x: col * grid.current.charWidth,\n          y:\n            row * grid.current.charHeight -\n            grid.current.rows * grid.current.charHeight,\n          color: getRandomColor(),\n        };\n      });\n\n      animationFrameId.current = requestAnimationFrame(animate);\n    };\n\n    const animate = (timestamp: number) => {\n      animationFrameId.current = requestAnimationFrame(animate);\n\n      if (timestamp - lastGlitchTime.current > glitchSpeed) {\n        lastGlitchTime.current = timestamp;\n        const updateCount = Math.floor(\n          letters.current.length * glitchIntensity,\n        );\n        for (let i = 0; i < updateCount; i++) {\n          const index = Math.floor(Math.random() * letters.current.length);\n          if (letters.current[index]) {\n            letters.current[index].char = getRandomChar();\n            letters.current[index].color = getRandomColor();\n          }\n        }\n      }\n\n      const totalFieldHeight = grid.current.rows * grid.current.charHeight * 2;\n      letters.current.forEach((letter) => {\n        letter.y += fallSpeed;\n        if (letter.y > canvasHeight) {\n          letter.y -= totalFieldHeight;\n        }\n      });\n\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n\n      ctx.font = `${fontSize}px monospace`;\n      ctx.textBaseline = \"top\";\n\n      letters.current.forEach((letter) => {\n        ctx.fillStyle = letter.color;\n        ctx.fillText(letter.char, letter.x, letter.y);\n      });\n    };\n\n    // ✅ Fixed debounce timer type\n    let resizeTimeout: ReturnType<typeof setTimeout>;\n    const handleResize = () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(setup, 150);\n    };\n\n    window.addEventListener(\"resize\", handleResize);\n    setup();\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n      if (animationFrameId.current) {\n        cancelAnimationFrame(animationFrameId.current);\n      }\n    };\n  }, [\n    symbols,\n    symbolColors,\n    fontSize,\n    backgroundColor,\n    glitchSpeed,\n    glitchIntensity,\n    fallSpeed,\n    getRandomChar,\n    getRandomColor,\n  ]);\n\n  return (\n    <div ref={containerRef} className={`relative ${className}`}>\n      <canvas ref={canvasRef} className=\"absolute inset-0 z-0\" />\n      {outerVignette && (\n        <div className=\"absolute inset-0 z-0 pointer-events-none bg-[radial-gradient(circle,_transparent_70%,_black_100%)]\"></div>\n      )}\n    </div>\n  );\n};\n\nexport default FallingSymbolsBackground;\n",
      "type": "registry:ui",
      "target": "components/ruixen/falling-symbols-background.tsx"
    }
  ]
}
{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "particle-text-dots",
  "type": "registry:ui",
  "title": "Particle Text Dots",
  "description": "Text rendered as interactive particle dots that react to cursor movement, similar to Gemini's background effect.",
  "files": [
    {
      "path": "registry/ruixenui/particle-text-dots.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ntype Variant = \"dark\" | \"light\";\r\n\r\ninterface ParticleTextDotsProps {\r\n  text: string;\r\n  variant?: Variant;\r\n  className?: string;\r\n}\r\n\r\ntype Particle = {\r\n  x: number;\r\n  y: number;\r\n  vx: number;\r\n  vy: number;\r\n  baseX: number;\r\n  baseY: number;\r\n  depth: number; // 0..1\r\n  size: number;\r\n  phase: number;\r\n};\r\n\r\ntype MouseState = {\r\n  x: number;\r\n  y: number;\r\n  active: boolean;\r\n};\r\n\r\nexport function ParticleTextDots({\r\n  text,\r\n  variant = \"dark\",\r\n  className,\r\n}: ParticleTextDotsProps) {\r\n  const containerRef = React.useRef<HTMLDivElement | null>(null);\r\n  const canvasRef = React.useRef<HTMLCanvasElement | null>(null);\r\n  const frameRef = React.useRef<number | null>(null);\r\n  const mouseRef = React.useRef<MouseState>({\r\n    x: 0,\r\n    y: 0,\r\n    active: false,\r\n  });\r\n\r\n  React.useEffect(() => {\r\n    const container = containerRef.current;\r\n    const canvas = canvasRef.current;\r\n    if (!container || !canvas) return;\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) return;\r\n\r\n    let disposed = false;\r\n    let width = 0;\r\n    let height = 0;\r\n    let particles: Particle[] = [];\r\n\r\n    const dpr = window.devicePixelRatio || 1;\r\n\r\n    const createParticlesFromText = (\r\n      w: number,\r\n      h: number,\r\n      raw: string\r\n    ): Particle[] => {\r\n      const label = raw.trim() || \"3\";\r\n\r\n      const off = document.createElement(\"canvas\");\r\n      off.width = w;\r\n      off.height = h;\r\n      const octx = off.getContext(\"2d\");\r\n      if (!octx) return [];\r\n\r\n      octx.clearRect(0, 0, w, h);\r\n\r\n      const maxFontHeight = h * 0.65;\r\n      const approxCharWidth = 0.6;\r\n      const targetWidth = w * 0.8;\r\n      const fontSize = Math.min(\r\n        maxFontHeight,\r\n        targetWidth / Math.max(1, label.length * approxCharWidth)\r\n      );\r\n\r\n      octx.fillStyle = variant === \"dark\" ? \"#ffffff\" : \"#020617\";\r\n      octx.textAlign = \"center\";\r\n      octx.textBaseline = \"middle\";\r\n      octx.font = `800 ${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, \"SF Pro Display\", sans-serif`;\r\n      octx.fillText(label, w / 2, h / 2);\r\n\r\n      const img = octx.getImageData(0, 0, w, h);\r\n      const data = img.data;\r\n\r\n      // spacing: between the tight first version and the more scattered one\r\n      const baseGap = Math.min(w, h) / 65;\r\n      const gap = Math.max(5, Math.round(baseGap)); // ~5px\r\n      const alphaThreshold = 70;\r\n\r\n      const pts: Particle[] = [];\r\n\r\n      for (let y = 0; y < h; y += gap) {\r\n        for (let x = 0; x < w; x += gap) {\r\n          const idx = (y * w + x) * 4;\r\n          const alpha = data[idx + 3];\r\n          if (alpha > alphaThreshold) {\r\n            const depth = Math.random(); // 0..1\r\n\r\n            // small jitter -> still organic, but not scattered\r\n            const jitterX = (Math.random() - 0.5) * gap * 0.2;\r\n            const jitterY = (Math.random() - 0.5) * gap * 0.2;\r\n            const baseX = x + jitterX;\r\n            const baseY = y + jitterY;\r\n\r\n            // spawn slightly offset so they \"settle\" into place\r\n            const startOffset = 22;\r\n            const sx = baseX + (Math.random() - 0.5) * startOffset;\r\n            const sy = baseY + (Math.random() - 0.5) * startOffset;\r\n\r\n            pts.push({\r\n              x: sx,\r\n              y: sy,\r\n              vx: 0,\r\n              vy: 0,\r\n              baseX,\r\n              baseY,\r\n              depth,\r\n              size: 1.4 + depth * 1.3, // clean circular dots\r\n              phase: Math.random() * Math.PI * 2,\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      return pts;\r\n    };\r\n\r\n    const resize = () => {\r\n      const rect = container.getBoundingClientRect();\r\n      width = Math.max(1, Math.floor(rect.width));\r\n      height = Math.max(1, Math.floor(rect.height));\r\n\r\n      canvas.width = width * dpr;\r\n      canvas.height = height * dpr;\r\n      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\r\n\r\n      particles = createParticlesFromText(width, height, text);\r\n\r\n      mouseRef.current.x = width / 2;\r\n      mouseRef.current.y = height / 2;\r\n    };\r\n\r\n    resize();\r\n    const ro = new ResizeObserver(resize);\r\n    ro.observe(container);\r\n\r\n    let lastTime = performance.now();\r\n\r\n    const render = (time: number) => {\r\n      if (disposed) return;\r\n\r\n      const dtMs = time - lastTime;\r\n      lastTime = time;\r\n      const dt = Math.min(2, dtMs / 16.67); // normalized (~1 at 60fps)\r\n\r\n      const t = time * 0.0012;\r\n      const mouse = mouseRef.current;\r\n\r\n      ctx.clearRect(0, 0, width, height);\r\n\r\n      const influenceRadius = Math.min(width, height) * 0.35;\r\n      const influenceRadiusSq = influenceRadius * influenceRadius;\r\n\r\n      // physics\r\n      for (const p of particles) {\r\n        // mouse push\r\n        if (mouse.active) {\r\n          const dxm = p.x - mouse.x;\r\n          const dym = p.y - mouse.y;\r\n          const distSq = dxm * dxm + dym * dym;\r\n          if (distSq < influenceRadiusSq && distSq > 0.0001) {\r\n            const dist = Math.sqrt(distSq);\r\n            const force = (1 - dist / influenceRadius) * 1.5;\r\n            const nx = dxm / dist;\r\n            const ny = dym / dist;\r\n            const k = force * (0.4 + p.depth * 0.6);\r\n            p.vx += nx * k;\r\n            p.vy += ny * k;\r\n          }\r\n        }\r\n\r\n        // spring back to glyph\r\n        const spring = 0.06 + p.depth * 0.03;\r\n        const dx = p.baseX - p.x;\r\n        const dy = p.baseY - p.y;\r\n        p.vx += dx * spring * dt;\r\n        p.vy += dy * spring * dt;\r\n\r\n        // gentle float (reduced so they don't look scattered)\r\n        const wobble = 0.07 + p.depth * 0.09;\r\n        p.vx += Math.cos(t * 1.2 + p.phase) * wobble * 0.16 * dt;\r\n        p.vy += Math.sin(t * 1.3 + p.phase) * wobble * 0.16 * dt;\r\n\r\n        // friction\r\n        p.vx *= 0.9;\r\n        p.vy *= 0.9;\r\n\r\n        p.x += p.vx * dt;\r\n        p.y += p.vy * dt;\r\n      }\r\n\r\n      // draw clean dots (no halo)\r\n      for (const p of particles) {\r\n        const dx = p.x - mouse.x;\r\n        const dy = p.y - mouse.y;\r\n        const dist = Math.sqrt(dx * dx + dy * dy) || 1;\r\n        const near = mouse.active\r\n          ? Math.max(0, 1 - dist / influenceRadius)\r\n          : 0;\r\n\r\n        // subtle, slow twinkle\r\n        const flickerBase =\r\n          (Math.sin(t * 1.0 + p.phase * 1.7) + 1) * 0.5; // 0..1\r\n        const flicker = 0.85 + 0.15 * flickerBase; // 0.85..1.0\r\n\r\n        const depthFactor = 0.55 + p.depth * 0.45;\r\n        const alpha = (0.55 + 0.3 * near) * depthFactor * flicker;\r\n\r\n        const hue =\r\n          variant === \"dark\" ? 210 + p.depth * 40 : 220 + p.depth * 30;\r\n        const lightness =\r\n          variant === \"dark\" ? 63 + p.depth * 18 : 50 + p.depth * 15;\r\n\r\n        ctx.fillStyle = `hsla(${hue}, 90%, ${lightness}%, ${alpha})`;\r\n        ctx.beginPath();\r\n        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\r\n        ctx.fill();\r\n      }\r\n\r\n      frameRef.current = requestAnimationFrame(render);\r\n    };\r\n\r\n    frameRef.current = requestAnimationFrame(render);\r\n\r\n    return () => {\r\n      disposed = true;\r\n      ro.disconnect();\r\n      if (frameRef.current !== null) cancelAnimationFrame(frameRef.current);\r\n    };\r\n  }, [text, variant]);\r\n\r\n  const handlePointerMove: React.PointerEventHandler<HTMLDivElement> = (e) => {\r\n    const rect = e.currentTarget.getBoundingClientRect();\r\n    mouseRef.current.x = e.clientX - rect.left;\r\n    mouseRef.current.y = e.clientY - rect.top;\r\n    mouseRef.current.active = true;\r\n  };\r\n\r\n  const handlePointerLeave: React.PointerEventHandler<HTMLDivElement> = () => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n    const rect = container.getBoundingClientRect();\r\n    mouseRef.current.x = rect.width / 2;\r\n    mouseRef.current.y = rect.height / 2;\r\n    mouseRef.current.active = false;\r\n  };\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      onPointerMove={handlePointerMove}\r\n      onPointerLeave={handlePointerLeave}\r\n      className={cn(\r\n        \"relative w-full overflow-hidden rounded-3xl border\",\r\n        \"min-h-[260px] sm:min-h-[320px] md:min-h-[360px]\",\r\n        \"shadow-[0_22px_90px_rgba(0,0,0,0.7)]\",\r\n        variant === \"dark\"\r\n          ? \"border-slate-800 bg-black\"\r\n          : \"border-slate-200 bg-slate-50\",\r\n        className\r\n      )}\r\n    >\r\n      <canvas\r\n        ref={canvasRef}\r\n        className=\"pointer-events-none absolute inset-0 h-full w-full\"\r\n      />\r\n      {/* subtle background glow only, no extra text */}\r\n      {variant === \"dark\" ? (\r\n        <div className=\"pointer-events-none absolute inset-0 bg-[radial-gradient(circle_at_top,_rgba(148,163,253,0.16),transparent_60%),radial-gradient(circle_at_bottom,_rgba(15,23,42,0.9),transparent_55%)]\" />\r\n      ) : (\r\n        <div className=\"pointer-events-none absolute inset-0 bg-[radial-gradient(circle_at_top,_rgba(59,130,246,0.16),transparent_60%),radial-gradient(circle_at_bottom,_rgba(15,23,42,0.05),transparent_55%)]\" />\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:ui",
      "target": "components/ruixen/particle-text-dots.tsx"
    }
  ]
}